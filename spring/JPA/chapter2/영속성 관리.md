# 영속성 컨텍스트란?

**영속성 컨텍스트 (Persistence context)**는 엔티티를 영구 저장하는 환경이다.

```java
em.persist(member);
```

위 코드는 **엔티티 매니저**를 사용해 회원 엔티티를 **영속성 컨텍스트에 저장**하는 코드이다.

# 엔티티의 생명주기

엔티티는 4가지 상태가 존재한다.

- 비영속 (new / transient) : 영속성 컨텍스트와 전혀 관계가 없는 상태
- 영속 (managed) : 영속성 컨텍스트에 저장된 상태
- 준영속 (detached) : 영속성 컨텍스트에 저장되었다가 분리된 상태
- 삭제 (removed) : 삭제된 상태

![](https://llmooon.github.io/assets/spring/jpa_persistance.PNG)

# 영속성 컨텍스트의 특징

- **영속성 컨텍스트와 식별자 값** : 영속성 컨텍스트에서는 엔티티를 식별자로 **구분**하기 때문에 **식별자 값이 반드시 있어야 한다.**
- **영속성 컨텍스트와 데이터베이스 저장** : 트랜잭션을 **커밋**하는 순간 영속성 컨텍스트에 새로 저장된 엔티티를 데이터 베이스에 반영하는데 이를 **플러시 (flush)**라 한다.

## 장점

영속성 컨텍스트가 엔티티를 관리하면 아래와 같은 장점이 있다.

- 1차 캐시
- 동일성 보장
- 트랜잭션을 지원하는 쓰기 지연
- 변경 감지
- 지연 로딩

## 엔티티 조회

영속성 컨텍스트는 내부에 **캐시**를 가지고 있는데 이를 **1차 캐시**라 하고 **영속 상태의 엔티티**를 캐시에 다 저장한다.

```java
// 비영속
Member member = new Member();
member.setId("member1");
member.setUsername("회원1");
// 영속
em.persist(member);
```

위 코드를 실행하면 회원 엔티티를 1차 캐시에 저장하지만 데이터베이스에는 저장되지 않는다.

```java
// 조회
Member member = em.find(Member.class, "member1");
```

위 코드를 실행하면 1차 캐시에서 엔티티를 찾고 만약 엔티티가 없으면 데이터베이스에서 조회한다.

### 데이터베이스에서 조회

만약 em.find()를 호출햇는데 엔티티가 1차 캐시에 없으면 데이터베이스에서 조회해서 엔티티를 생성한다.

그리고 1차 캐시에 저장한 후 영속상태의 엔티티를 반환한다.

### 장점

- 영속성 컨텍스트는 성능상 이점과 엔티티의 동일성을 보장한다.

## 엔티티 등록

- 엔티티 매니저는 **트랜잭션을 커밋**하기 전까지 데이터베이스에 저장하지 않고 **내부 쿼리 저장소**에 쿼리들을 모아둔다.

```java
EntityTransaction transaction = em.getTransaction();
transaction.commit();
```

위 코드를 실행하면 모아둔 쿼리를 실행하는데 이를 **쓰기 지연 (transactional wirte-behind)**이라고 한다.

## 엔티티 수정

JAP에서는 엔티티를 수정하는 메소드가 따로 없고 엔티티 데이터가 변경되면 자동으로 데이터베이스에 반영이 되는데 이 기능을 **변경 감지 (dirty checking)**이라 한다. 

### 변경감지

1. JPA는 엔티티를 영속성 컨텍스트에 저장할 때, **최초 상태**를 복사해서 저장해두는데 이것을 **스냅샷**이라 한다.
2. 플러시 시점에 스냅샷과 엔티티를 비교해서 **엔티티가 변경**되었으면 **수정 쿼리를 생성**해 쓰지 지연 저장소에 보낸다.
3. **트랜잭션을 커밋**하면 쓰기 지연을 한다.

<aside>
💡 변경 감지는 영속성 컨텍스트가 관리하는 **영속 상태**의 엔티티에만 적용한다.

</aside>

## 엔티티 삭제

엔티티를 삭제하려면 먼저 삭제할 엔티티를 조회해야 한다.

```java
Member memberA = em.fing(Member.class, "memberA");
em.remove(memberA);
```

위 코드를 실행하면 조회를 하고 **삭제 쿼리를 쓰기 지연 저장소**에 저장한 뒤 트랜잭션을 커밋할 때 쿼리문을 날린다.

<aside>
💡 em.remove ( )를 실행하면 영속성 컨텍스트에서 제거된다. 
→ 재사용 하지 말자.

</aside>

# 플러시

**플러시 (flush ()**)는 영속성 컨텍스트의 **변경 내용**을 데이터베이스에 반영한다.

호출 하는 방법은 3가지이다.

- em.flush ( )를 직접 호출한다.
- 트랜잭션 커밋 시 플러시가 자동 호출된다.
- JPQL 쿼리 실행 시 플러시가 자동 호출된다.

# 준영속

- 영속 상태의 엔티티가 영속성컨텍스트에서 분리된 것이 **준영속** 상태이다.
- 준영속 상태의 엔티티는 **영속성 컨텍스트가 제공하는 기능**(변경 감지, 지연 쓰기 등)을 사용할 수 없다.

준영속 상태로 만드는 방법은 3가지다.

- em.detch (entity) : 특정 엔티티만 준영속 상태로 전환한다.
- em.clear ( ) : 영속성 컨텍스트를 완전히 초기화한다.
    - 해당 영속성 컨텍스트의 모든 엔티티를 준영속 상태로 만든다.
- em.close ( ) : 영속성 컨텍스트를 종료한다.
    - 해당 영속성 컨텍스트의 모든 엔티티를 준영속 상태로 만든다.

## 특징

- 거의 비영속 상태에 가깝다
    
    → 영속성 컨텍스트가 제공하는 기능들이 동작하지 않기 때문이다.
    
- 식별자 값을 가지고 있다.
- 지연 로딩을 할 수 없다.

## 병합 : merge( )

- 병합은 준영속 상태의 엔티티를 다시 영속 상태로 변경할 때 사용한다.
- 병합은 준영속 상태의 엔티티를 받아 **새로운 영속 상태의 엔티티**를 반환한다.

```java
Member mergeMember = em.merge(member);
```

## 비영속 병합

- 병합은 비영속 엔티티도 영속 상태로 만들 수 있다.

```java
Member member = new Member();
Member newMember = em.merge(member);
tx.commit();
```