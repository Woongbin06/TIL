# 객체
정의 : 세상에 존재하는 모든 것, 주변에 있는 사물이나 생명체들 모두를 뜻함.  
용도 : 객체의 속성과 기능에 따라 용도가 바뀜.

## 1. 클래스란 ?
정의 : **객체를 정의해** 놓은 것.  
용도 : 객체를 생성하는 데 사용됨.   

``` java
class 클래스명 { // 클래스 생성
}
public class 클래스명 {
	public static void main(String[] args) {
    	Test t = new Test(); // 객체 생성
    }
}
```

## 생성자(Constructor)
new 연산자를 통해서 인스턴스를 생성할 때 제일 먼저 실행되는 메소드.

> ### 생성자의 특징   
>- 클래스명과 **동일하게** 정의해야 함.  
>- 생성자 앞에는 **접근제어자만** 올수 있다.  
>- 반환값이 없으므로 void나 자료형을 작성할 수 없다.

![img](https://postfiles.pstatic.net/MjAxNzAzMTFfMTEx/MDAxNDg5MjE1NjY3NTMy.RwZLVzC4xP0CwndhcsODDc2lWVo9i5y0JlNPpOBU8FAg.V16bJttp3SVjh--Z_m2LJCobzBeCafwWQLXDdy4Rr68g.PNG.heartflow89/image.png?type=w773)

## 2. 객체지향언어란 ?
객체를 만들고 조작하며 객체끼리 관계를 맺음으로써 다수의 함께 수행되는 언어를 말함.

## 3. 객체와 인스턴스
객체(Object)는 인스턴스(instance)를 포함하는 일반적인 의미.   
인스턴스화 : **클래스로부터** 인스턴스를 생성하는 것.
## 4. 인스턴스의 생성과 사용
생성 방법 : 클래스명 참조변수명;  
참조변수명 : new 클래스명();
> ### 인스턴트의 특징
> - 참조변수.매서드명으로 객체에 접근 가능
> - 하나의 인스턴스를 여러개의 참조 변수가 가르키는 경우는 가능함.
> - 여러개의 인스턴스를 하나의 참조변가 가르키는 경우는 불가능함.

## 5. 객체 배열
클래스를 배열로 선언하는 것.

> ### 사용하는 이유 
> - 객체는 메모리에서 single record만 표현 가능.  
> 따라서 multiple record를 표현할 시 객체 배열을 사용.
> - 다양한 타입의 데이터를 객체 배열에 저장할 수 있기 때문.  

| 기본 배열 | 객체 배열 | 
| :-: | :-: |
| 선언과 동시에 메모리 생성 | 선언과 동시에 메모리 생성 X | 

### ※ 따라서 객체 배열은 메모리를 따로 생성하는 과정이 필요함.


# 6. 메소드
객체 프로그래밍에서 관련된 **서브 루틴**이며, 데이터와 **멤버 변수**에 대한 접근 권한을 갖음
> 서브루틴 : 반복되어 사용하는 것을 메모리에 한번에 적재하여 **여러번*** 사용할 수 있도록 하는 방법.   
멤버 변수 : **메소드 밖**에서 선언된 변수.

## 6 - 1. 메소드를 사용하는 이유
1. 소스코드의 **가독성**
2. 소스코드의 **재사용성**

## 6 -2.메소드의 선언과 호출
**메소드 선언**

``` java
public static void 메소드명() {
  메서드작성;

  return 리턴 값; // 메소드를 종료시키고 리턴 값을 변수에 저장 시킬 수 있음.
}
```
**메소드 호출**
``` java
메소드(매개변수); // 매개변수는 없으면 생략 가능
```
## 6 - 3. 클래스 메소드
클래스 변수 : 클래스 전체와 연결된 필드
클래스 메소드 : 클래스 전체와 연결된 메소드

``` java
class Car {
  public static int sum = 0;

  public static void ShowSum() {
    System.out.println(sum);
  }
}
```
※ 클래스 변수와 메소드를 선언할 때 static을 붙여야 함.
> static 클래스 변수 : 같은 클래스의 객체들이 다루는 데이터를 저장하는 변수   
static 클래스 메소드 : 특정 클래스 객체에 포함X -> 객체를 생성하지 않아도 사용할 수 있음.

## 6 - 4. 인스턴스 메소드
인스턴스 메소드는 반드시 **객체**에서만 호출 가능.

| 클래스 메소드 | 인스턴스 메소드 | 
| :-: | :-: | 
| 인스턴스 생성 할 필요 X | 인스턴스 생성 해야 함.

## 6 - 5. 클래스 멤버와 인스턴스 멤버의 참조와 호출
- 같은 클래스에 있는 멤버들 간에는 인스턴스 생성하지 않고 호출 가능.
- 클레스 멤버가 인스턴스 멤버를 호출할 때는 인스턴스를 생성해야 함.
- 인스턴스 멤버는 반드시 객체가 생성된 후에만 참조 가능.

# 상속(Inheritance)
자식 클래스가 상속받고 싶은 부모 클래스를 선택해서 물려 받는 것.

> 이때 상속받는 클래스를 자식, 하위, 서브 클래스라고 한다.  
상속해주는 클래스를 부모, 상위, 슈퍼 클래스라고 한다.

## 상속의 선언 방법
자식 클래스 뒤에 extends를 쓰고 부모 클래스를 쓴다.
![img](https://postfiles.pstatic.net/MjAxNzAzMTVfMjg2/MDAxNDg5NTg3Njk3Nzc3.Rk08cHWylj483VWcKRYlrap4XP1m_-FTmR5VhWxmG9Ig.9XRVJRczh7PQehqrfUs1N-usfyhb3MNbY1EW_qZnCsEg.PNG.heartflow89/image.png?type=w773)

> ## 주 의 할 점   
- 다중 상속을 받는 것은 불가능.   
- 즉 단일 상속만 허용.
- 부모 클래스에는 여러 개의 자식 클래스에게 상속 가능.

### **TIP !**
자식 클래스가 더 다양한 기능이 가능하므로 자식 클래스를 인스턴스로 생성하는 것이 효율적.

# super와 super( )
**super**는 부모 클래스로부터 상속받은 필드나 메소드를 자식 클래스에서 참조할때 사용하는 변수.

**super( )** 는 부모 클래스의 생성자를 호출하는 메소드.

# 오버로딩(Overloading)
한 클래스 내에 이미 사용하려는 이름과 같은 이름을 가진 메소드가 있더라도 매개변수의 개수 또는 타입이 다르면, 정의할 수 있는 것.
## 😁오버로딩의 조건
- 매소드의 이름이 같아야 함.
- 매개변수의 개수나 타입이 달라야 함.
- 접근 제어자도 자유롭게 지정 가능.

※ **리턴 값**만 다른 것은 오버로딩 불가

## 😙오버로딩을 사용하는 이유
1. 같은 기능을 하는 메소드를 하나의 이름을 사용 가능.
2. 메소드의 이름 절약 가능.

# 오버라이딩(Overriding)
부모 클래스로부터 상속받은 메소드를 자식 클래스에서 재정의 하는 것.

## 😗오버라이딩의 조건
자식 클래스에서 오버라이딩하고자 하는 메소드의 이름, 매개변수, 리턴 값이 모두 같아야 함.

## 🤔오버라이딩의 특징
1. 자식 클래스에서 오버라이딩하는 메소드의 접근 제어자는 부모 클래스보다 더 좁게 불가.
2. 예외는 부모 클래스의 메소드 보다 많이 선언 불가.
3. static메소드를 인스턴스의 메소드로 또는 그 반대로 변경 불가.

# 오버라이딩과 오버로딩의 공통점, 차이점
| 오버라이딩 | 오버로딩 |
| :-: | :-: |
| 자식 클래스의 접근 제어자 (범위) > 부모 클래스의 접근 제어자  | 모든 접근 제어자 |
| 리턴형 동일 | 리턴형 달라도 됨 |
| 메소드명 동일 | 메소드명 동일 |
| 매개변수 동일 | 매개변수 달라야 됨 |
| 적용 범위 상속관계 | 적용 범위 같은 클래스 내 |