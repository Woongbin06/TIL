## HTTP는 클라리언트와 서버 간에 통신을 한다.

- HTTP도 클라이언트와 통신을 한다.
- 항상 서버와 클라이언트가 있어야 한다.

### 통신 방법

1. 클라이언트가 서버에게 `리퀘스트(요청)`을 보낸다.
2. 서버가 그 요청에 대한 `리스폰스(응답)`을 보낸다.

- 리퀘스트은 메소드, URI, 프로토콜, 버전 옵션 리퀘스트 헤더 필드와 엔티티로 구성되어 있다.

![](https://velog.velcdn.com/images/dovnaldisn/post/b561b26e-f376-4c42-9f41-e64d989e2e6e/image.png)


- 리스폰스는 프로토콜 버전, 상태 코드, 상태 코드를 설명하는 프레이즈, 리스폰스 헤더 필드와 바디로 구성되어 있다.

![](https://velog.velcdn.com/images/dovnaldisn/post/e1fc4996-a555-40a6-97c1-841cb1fef1d5/image.png)

***

## HTTP는 상태를 유지하지 않는 프로토콜
HTTP는 상태를 계속 유지하지 않는 스테이트리스(stateless) 프로토콜이다.   
즉 HTTP 프로토콜은 이전에 보냈던 리퀘스트나 리스폰스를 기억하지 못한다.

***

## 리퀘스트 URI로 리소스를 식별
- HTTP는 URI를 사용하여 인터넷 상의 리소스를 지정한다.
- URI가 있는 덕분에 인터넷 상의 어떤 장소에 있는 리소스도 호출할 수 있다.


리퀘스트 안에 URI를 리퀘스트 URI라고 불리는 형식으로 포함해야 하는데 여러 방법이 있다.

1. 모든 URI를 리퀘스트 URI에 포함한다.
2. Host 헤더 필드에 네트워크 로케이션을 포함한다.

***

## HTTP 메소드
- GET : 리퀘스트 URI로 식별된 리소스를 가져올 수 있도록 요구한다.
- POST : 엔티티를 전송하기 위해 사용한다.
- PUT : 파일을 전송하기 위해 사용한다.
- HEAD : GET과 같지만 메시지 바디는 돌려주지 않는다.
- DELETE : 파일을 삭제하기 위해 사용한다.
- OPTIONS : 리퀘스트 URI로 지정한 리소스가 제공하고 있는 메소드를 조사하기 위해 사용한다.
- TRACE : Web 서버에 접속해서 자신에게 통신을 되돌려 받는 루프백을 발생시킨다.
- CONNECT : TCP 통신을 터널링 시키기 위해 사용한다.

***

## 지속 연결
옛날에는 HTTP 통신을 한 번 할 때마다 TCP를 연결하고 종료를 반복해야 되서 쓸모없는 통신이 계속 늘어났다.   
이를 해결하기 위해 `지속 연결`이라는 방법을 사용했다.

- 지속 연결은 연결을 종료하지 않는 이상 TCP 연결을 계속 유지한다.
- 연결과 종료를 반복하는 과정이 줄어 서버에 대한 부하가 줄어든다.
- 통신 속도가 빨라진다.

### 파이프라인화
지속 연결에서 여러 리퀘스트를 보낼 수 있도록 파이프라인화를 해야한다.

- 파이프라인화를 하면 리퀘스트를 보내고 리스폰스를 기다리지 않고 다음 리퀘스트를 바로 보낼 수 있다.

***

## 쿠키를 사용한 상태 관리

HTTP은 스테이트리스 프로토콜이기 때문에 예전에 했던 리퀘스트와 리스폰스를 기억한다.   
이는 로그인이 필요한 웹 페이지에서 로그인 상태를 유지 못하기 때문에 새로운 페이지로 갈 때마다 로그인을 다시해야 한다는 문제가 생긴다.   
이를 쿠키를 사용하여 해결할 수 있다.

- 쿠키는 클라이언트에 보존한다.
- 리퀘스트나 리스폰스에서 쿠키를 같이 보낸다.

### 과정
1. 쿠키를 가지지 않은 상태에서 리퀘스트를 보내면 서버에서 쿠키를 붙여서 리스폰스를 해준다.
2. 쿠키를 가지고 있는 상태에서 리퀘스트를 보내면 서버에서 쿠키를 확인해 서버 상의 기록과 어떤 클라리언트가 접속했는지 체크할 수 있다.