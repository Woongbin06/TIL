### 자바의 동작원리
<ol>
  <li>클래스 로더 (Class Loader)</li>
  <ol type = "A">
    <li>계층구조</li>
    <li>위임모델</li>
    <li>가시성 제한</li>
    <li>언로드(Unload) 불가</li>
    <li>이름공간(Name Space)</li>
  </ol>
  <li>런타임 데이터 영역 (Runtime Data Area)</li>
  <li>실행 엔진 (Execution Engine)</li>
</ol>

>- 런타임 데이터 영역 : JVM이 OS위에서 실행되면서 할당받는 메모리 영역
>- 실행 엔진 (Execution Engine) : 클래스 로더를 통해 런타임 데이터 영역에 배치된 바이트 코드를 명령어 단위로 읽어서 실행시켜줌.

<h3>자바의 특징</h3>
<ul>
  <li><a>플랫폼이 독립적</a> (운영체제와 상관없이 실행 가능)</li>
  <li>객체지향언어</li>
  <li>함수형코딩 지원</li>
  <li>분산처리 지원</li>
  <li>멀티쓰레드 지원</li>
</ul>
<p>JVM : Java Virtual Machine</p>
<p>JDK : Java Development Kit (자바개발도구)</p>
<p>JRE : Java Runtine Environment (자바 실행환경)</p>

>- JDK는 사용가능한 <a>블록</a>을 모아놓은 개념.
>- Java 실행파일은 완성된 <a>블록</a> 개념.
>- JRE는 완성된 블록을 세워(실행) 놓을 수 있는 <a>널찍한 판</a>

<h3>기본 구조 및 문법</h3>
<p><a>소스파일</a>은 src 폴더 내에 존재함 (.java)</p>
<p><a>바이트코드</a>는 bin 폴더 내에 존재함(.class)</p>
<ul>
  <li>주석</li>
  <ul>
    <li>/* 주석내용 */ : 여러줄을 주석 처리</li>
    <li>// 주석내용 : 한 줄만 주석 처리</li>
  </ul>
  <li>클래스 ( public class Test { ... } )</li>
  <ul>
    <li>public : 접근지정자 키워드 (<a>파일당</a> 최대 1개까지)</li>
    <li>class : 클래스의 이름 앞에 오는 예약어</li>
    <li>클래스 이름은 자유롭게 선정 가능 but 소스 파일 이름과 동일 해야 함</li>
  </ul>
  <li>매서드 ( public static void main(String[] args) { ... } )</li>
  <ul>
    <li>static : 정적 매서드 키워드</li>
    <li><a>메서드의 원형 : 반환타입 메서드이름 ( ... ) { ... }</a></li>
  </ul>
</ul>

### 변수
- 프로그래밍에서 값를 사용 하기 위해 선언 하는 것
- 할당 받은 메모리의 주소 대신 부르는 이름
- 프로그램 실행 중에 값 변경 가능
- 사용되기 이전에 선언 되어야 함

※ 변수의 선언 방법과 초기화
데이터 형식 | 변수의 이름;
초기화 : 변수의 이름 = 대입할 값

> 변수의 명명 규칙
>- 하나 이상의 글자로 이루어져야 함
>- 첫 번째 글자는 문자이거나 '$', ' _ ' 이여야함(숫자 X)
>- '$', ' _ '이외의 특수문자 사용 불가능
>- 키워드는 식별자로 사용 불가
>- 길이 제한 X

### 기본형(primitive type) 변수
논리형: boolean(true, false)
문자형: char(2^16)
정수형: byte, short, int, long
실수형: float, double
### 자료형 없이 변수 사용
자료형이 필요한 이유 : 변수를 선언 할 때 변수가 사용할 메모리 크키와 타입을 구분하기 위해.
지역 변수 자료형 추론 : 변수에 대입되는 값을 보고 컴파일러가 추론.
### 상수
상수 : 변하지 않는 값
상수의 선언 : **fianl** 키워드 사용
ex ) final double PI = 3.14;
**final로 선언된 상수는 다른 값을 대입 할 수 없음.**
### 리터럴(literal)
리터럴 : 프로그램에서 사용하는 모든 숫자, 값, 논리 값
  ex ) 10, 3.14, 'A', true, false
### 형 변환(캐스팅)
묵시적 형변환 : 작은 수에서 큰수로/덜 정밀한 수에서 더 정밀한 수로 대입되는 경우
``` java
int x = 50000;
long y = x; // 묵시적 형변환 발생
```
 
명시적 형변환 : 묵시적 형 변환의 반대의 경우/변환 되는 자료 형을 명시해야 함. 자료의 손실이 발생 할 수 있음

```java
double num = 3.14;
int num1 = (int)num; // 명시적 형변환 발생
```
### 연산자의 종류

- 증감 연산자 ex) ++, --
- 산술 연산자 ex) +, -, *, /, %
- 시프트 연산자 ex) >>, <<, >>>
- 비교 연산자 ex) >, <, >=, <=, ==, !=
- 비트 연산자 ex) &, |, ^, ~
- 논리 연산자 ex) &&, ||, !
- 조건(삼항) 연산자 ex) ?, :
- 대입 연산자 ex) =, *=, /=, %=, +=, -=

### 조건문의 종류
조건문은 크게 if문과 switch문으로 나뉜다.

#### 1. if문
if(**조건식**) { // 조건이 참일 때 실행 함.
	실행문;
}
#### 2. else if문
if(**조건식**) {
실행문;
{
else { // if의 조건이 거짓일 때 실행 함.
실행문
}
#### 3. switch문
switch(**변수**) {
      case 1 : 실행문; // 변수의 값이 1일 때 실행 후  break로 switch문 탈출.
	break;
	case 2 : 실행문;
	break;
	default : 실행문; // 위에 조건이 다 거짓일 때 실행 함.
}
### 반복문의 종류
반복문의 종류는 while, do while, for, Enhanced for문으로 나뉜다.
#### 1. while문
```java
while(**조건식**)
{
      실행문;
      증감문;
}
```
#### 2. do while문
```java
do { // 무조건 한번 실행
	실행문;
	증감문;
} while(**조건문**)
```
#### for문
```java
for(초기식; 조건식; 증감식) { // 초기식, 조건식, 증감식이 한번에 들어감
	실행문;
}
```
#### Enhanced for문
```java
for(초기화 : 배열) { // 배열이 끝날 때 까지 실행
	실행문;
}
```
> **Enhanced for문**
>- 배열에서만 사용 가능. 
>- 배열의 크기 조사할 필요 X
>- 배열 값 변경 불가.

### 배열이란?
동일한 자료형의 데이터를 연속된 공간에 저장하기 위한 자료구조

> **배열의 장점**
>- 변수의 선언을 줄여줌.
>- 반복문 등을 이용하여 계산과 같은 과정을 쉼게 처리.

### 배열의 선언 방법
자료형[ ] 변수명 = { 데이터1, 데이터2 ... }; // 인덱스는 0부터

**호출방법**
Systeam.out.println(변수명[ **원하는 인덱스 번호** ]);
``` java
int[] x = { 1, 2 }; // 선언과 초기화
System.out.println(x[1]); // 2를 출력
```

### 변수 타입에 따른 기본값
- Boolean : false
- char : \u0000
- byte/short/int : 0
- long : 0L
- float : 0.0f
- double : 0.0d 또는 0.0
- 참조형 : null

### 2차원 배열의 선언 방법
자료형[ ][ ] 변수명;
변수명[인덱스1][인덱스2] = 대입할 값; // 변수에 대입하는 방법

**호출방법**
System.out.println(변수명[인덱스1][인덱스2]);
``` java
char[][] x = { { 'a', 'b' }, { 'c', 'd' } }; // 선언과 초기화
System.out.println(x[0][1]); // b를 출력
```
이렇게 배열을 사용하면 변수의 선언을 적게 할 수 있어 코드가 간단해지고 가독성이 높아진다.